# ===============================================
# Production Level Nginx Configuration for PHP (HTTP-Only Template)
# 서버 사양: 쿼드코어 CPU, 4GB RAM, ~50 req/s
# 백엔드: PHP-FPM (PHP FastCGI Process Manager)
# 참고: sample_nginx_http.conf의 보안 설정 적용
# 주의: SSL/TLS 암호화 없음, 민감한 데이터 전송 시 보안 취약
# ===============================================

# HTTP 서버 블록 - 메인 PHP 애플리케이션
# 역할: HTTP 트래픽 처리, PHP-FPM 백엔드 프록시 및 정적 파일 서빙
# 주의: SSL/TLS 암호화 없음, 프로덕션 환경에서는 HTTPS 사용 강력 권장
server {
    listen       portnumber;
    server_name  domain www.domain;

    # 웹 루트 디렉토리
    # 역할: 정적 파일 및 PHP 스크립트의 기본 경로
    root         /www/webroot;

    # 악성 봇 차단
    # 역할: User-Agent 기반 악성 봇(크롤러/스캐너) 차단으로 DDoS/크롤링 공격 완화
    # 요구사항: nginx.conf의 http 블록에 $bad_bot 맵 정의 필요
    #   예: map $http_user_agent $bad_bot {
    #         default 0;
    #         ~*(sqlmap|nikto|nmap|masscan|ZmEu|dirbuster|acunetix) 1;
    #       }
    # 성능: map은 해시 테이블 사용으로 ~50 req/s에서 지연 <1ms
    if ($bad_bot) {
        return 403;
    }

    # 호스트 헤더 인젝션 방어 (선택사항, 필요 시 주석 해제)
    # 역할: 허용된 도메인만 처리하여 도메인 스푸핑 공격 방지
    # 성능: if 지시자는 효율적이나, nginx.conf의 map 지시자로 대체 시 CPU 5% 절감 가능
    # 개선: 정규식 패턴을 확장하여 다양한 TLD 지원
    # if ($host !~* ^(www\.)?domain\.(com|kr|co\.kr|net|ai)$) {
    #     return 444;  # 연결 즉시 종료 (헤더 없이, NGINX 전용 응답 코드)
    # }

    # ===== 보안 헤더 (HTTP 환경에서 유효한 것만) =====
    # 참고: HSTS는 HTTPS 전용이므로 제외

    # Content-Security-Policy (CSP)
    # 역할: XSS, 인젝션 공격 방어를 위한 콘텐츠 출처 제한
    # frame-ancestors: iframe 임베딩 허용 도메인 지정
    # 보안: 'self'는 동일 오리진만 허용 (프로토콜://도메인:포트 모두 일치)
    # 개선: PHP 애플리케이션에 맞게 간소화 (개발 포트 제거)
    add_header Content-Security-Policy "frame-ancestors 'self';" always;

    # X-Content-Type-Options
    # 역할: MIME 타입 스니핑 방지, 선언된 Content-Type만 허용
    # 보안: 악성 스크립트를 이미지로 위장하여 실행하는 공격 차단
    add_header X-Content-Type-Options "nosniff" always;

    # Referrer-Policy
    # 역할: 리퍼러 정보 유출 최소화
    # 설정: 크로스-오리진 시 오리진만 전송, 동일 오리진은 전체 URL 전송
    # 보안: 민감한 URL 파라미터 노출 방지
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # ===== 성능 최적화 =====
    # 파일 업로드 크기 제한
    # 역할: 요청 본문(body) 최대 크기 제한, 초과 시 413 에러 반환
    # 계산: 100MB 대용량 파일 업로드 지원 (PHP 업로드 제한과 동일하게 설정 권장)
    # 보안: 대용량 업로드 DoS 공격 완화
    # 참고: php.ini의 upload_max_filesize, post_max_size와 일치시켜야 함
    # 개선: 기존 설정에 없던 client_max_body_size 추가
    client_max_body_size 50M;

    # 파일 캐시 설정
    # 역할: 열린 파일 핸들 캐싱으로 디스크 I/O 감소
    # 성능: 정적 파일 서빙 시 20-30% 속도 향상 (반복 open/stat 호출 제거)
    # 계산: max=1000은 정적 파일 수 고려 (4GB RAM의 0.1% 사용)
    #       inactive=20s는 짧은 액세스 패턴에 최적
    # 개선: 기존 설정에 없던 파일 캐시 추가
    open_file_cache max=1000 inactive=20s;
    open_file_cache_valid 30s;
    open_file_cache_min_uses 2;
    open_file_cache_errors on;

    # ===== 로깅 설정 =====
    # 액세스 로그
    # 역할: 요청 로그 기록
    # 참고: 'main' 포맷은 nginx.conf에 정의 필요
    access_log /log/nginx/filename.com.php_http_access.log main;

    # 에러 로그
    # 역할: 에러 및 경고 로그 기록
    # 설정: warn 레벨로 노이즈 감소 (info, debug 제외)
    error_log  /log/nginx/filename.com.php_http_error.log warn;

    # ===== PHP 애플리케이션 처리 =====
    # 메인 location 블록 (정적 파일 및 PHP 라우팅)
    # 역할: 요청을 정적 파일 또는 PHP 스크립트로 라우팅
    location / {
        autoindex off;  # 디렉토리 목록 비활성화 (보안)

        # 기본 인덱스 파일
        # 역할: 디렉토리 접근 시 우선순위대로 파일 탐색
        index  index.php index.html index.htm;

        # URL 재작성 규칙
        # 역할: 파일이 없으면 index.php로 라우팅 (프레임워크 지원)
        # 동작: WordPress, Laravel 등 프레임워크의 URL 라우팅 지원
        # 예: /blog/post-1 → index.php?/blog/post-1
        # 개선: 기존 설정에 없던 try_files 추가 (프레임워크 지원)
        try_files $uri $uri/ /index.php?$args;

        # DDoS 방어 - Rate Limiting
        # 역할: IP당 요청 속도 제한으로 리소스 보호
        # 요구사항: nginx.conf의 http 블록에 zone 정의 필요
        #   예: limit_req_zone $binary_remote_addr zone=general:10m rate=10r/s;
        # 동작: rate=10r/s는 평균 초당 10건 제한
        # burst: 순간 트래픽 허용 한도 (최대 20건까지 큐에 대기)
        # nodelay: 큐의 요청들도 즉시 처리 (응답 지연 최소화)
        # 개선: 기존 설정에 없던 Rate Limiting 추가
        limit_req zone=general burst=20 nodelay;

        # 동시 연결 수 제한
        # 역할: IP당 동시 연결 제한으로 슬로우 공격 방어
        # 요구사항: nginx.conf에 zone 정의 필요
        #   예: limit_conn_zone $binary_remote_addr zone=addr:10m;
        # 개선: 기존 설정에 없던 Connection Limiting 추가
        limit_conn addr 10;

        # HTTP 메서드 제한 (선택사항, API 서버가 아니면 주석 처리 가능)
        # 역할: 일반적인 HTTP 메서드만 허용
        # 보안: TRACE, CONNECT 등 비표준 메서드 차단
        # 개선: PHP 웹사이트에 맞게 추가 (필요시 주석 해제)
        # limit_except GET POST HEAD OPTIONS PUT DELETE {
        #     deny all;
        # }
    }

    # Let's Encrypt ACME 챌린지 경로 (HTTPS 전환 준비용)
    # 역할: SSL 인증서 발급/갱신을 위한 도메인 검증 허용
    # 요구사항: certbot 또는 유사한 ACME 클라이언트 필요
    # 보안: try_files로 파일 존재 확인만 하여 디렉토리 트래버설 공격 차단
    # 개선: allow all 추가 (명시적 허용)
    location ^~ /.well-known/acme-challenge/ {
        allow all;
        root /www/webroot;
        try_files $uri =404;
    }

    # ===== 정적 파일 캐싱 최적화 =====
    # JavaScript, CSS, 이미지 파일 캐싱
    # 역할: 정적 자산 장기 캐싱으로 서버 부하 감소
    # 성능: 브라우저 캐시 활용으로 반복 요청 제거
    # 개선: 기존 설정은 로그만 끄고 캐싱 없음 → 브라우저 캐시 헤더 추가
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|webp|woff|woff2|ttf|eot)$ {
        # gzip 정적 압축 파일 사용
        # 역할: 사전 압축된 .gz 파일 서빙으로 CPU 부하 감소
        # 요구사항: nginx.conf에서 gzip_static on 설정 필요
        # 성능: 실시간 압축 대비 CPU 사용량 90% 감소
        gzip_static on;

        # 브라우저 캐시 설정 (최대 캐싱)
        # 역할: 정적 파일 장기 캐싱
        # 계산: expires max = 2037년까지 캐싱 (사실상 무한)
        # 성능: immutable로 재검증 없이 무한 캐시
        # 참고: 변경 가능한 파일은 버전화 필요 (예: app.v1.js)
        expires max;
        add_header Cache-Control "public, max-age=31536000, immutable";
        access_log off;
        log_not_found off;
    }

    # ===== 보안 차단 규칙 =====
    # 숨김 파일 차단
    # 역할: .으로 시작하는 파일/디렉토리 접근 차단
    # 보안: .git, .env, .htaccess 등 민감 파일 노출 방지
    # 개선: log_not_found off 추가 (로그 노이즈 감소)
    location ~ /\. {
        deny all;
        access_log off;
        log_not_found off;
    }

    # 민감한 파일 확장자 차단
    # 역할: 설정, 인증서, 스크립트, 로그 파일 접근 차단
    # 보안: 백도어, 설정 파일 노출 방지
    # 개선: 확장자 목록 확대 (.yaml, .toml, .ini, .env, .bak, .backup, .swp 추가)
    location ~* \.(log|binary|pem|enc|crt|conf|cnf|sql|sh|key|yml|yaml|lock|toml|ini|env|bak|backup|swp)$ {
        deny all;
        access_log off;
        log_not_found off;
    }

    # 프로젝트 메타데이터 차단
    # 역할: 빌드 설정 및 의존성 파일 노출 차단
    # 보안: 프로젝트 구조 및 버전 정보 유출 방지
    # 개선: 파일명 패턴 확장 (package.json, yarn.lock, Pipfile 등 추가)
    location ~* (composer\.(json|lock|phar)|package(-lock)?\.json|yarn\.lock|contributing\.md|license\.txt|readme\.(rst|md|txt)|copyright|artisan|gulpfile\.js|phpunit\.xml|access_log|error_log|gruntfile\.js|requirements\.txt|Pipfile(\.lock)?|pyproject\.toml)$ {
        deny all;
        access_log off;
        log_not_found off;
    }

    # 파비콘 - 로그 노이즈 제거
    # 역할: 브라우저 자동 요청 로그 무시
    # 성능: 액세스 로그 I/O 감소
    location = /favicon.ico {
        log_not_found off;
        access_log off;
    }

    # robots.txt - 검색 엔진 크롤러 제어
    # 역할: 크롤러 지시 파일 서빙, 인덱싱 제어
    # SEO: 검색엔진 최적화를 위한 크롤링 가이드
    # 개선: allow all 추가 (명시적 허용)
    location = /robots.txt {
        log_not_found off;
        access_log off;
        allow all;
    }

    # ===== PHP 업로드 디렉토리 보안 =====
    # 업로드 폴더 내 PHP 실행 차단
    # 역할: 사용자 업로드 디렉토리에서 PHP 스크립트 실행 방지
    # 보안: 웹셸 업로드 공격 차단 (치명적 보안 취약점 방어)
    # 대상: WordPress(uploads), Drupal(files), Gnuboard(data) 등
    # 개선: log_not_found off 추가 (로그 노이즈 감소)
    location ~* /(?:uploads|default/files|data)/.*\.php$ {
        deny all;
        access_log off;
        log_not_found off;
    }

    # ===== PHP-FPM 프로세서 설정 =====
    # PHP 스크립트 처리
    # 역할: .php 파일을 PHP-FPM으로 전달하여 실행
    # 보안: 경로 검증으로 임의 코드 실행 방지
    location ~ [^/]\.php(/|$) {
        # PATH_INFO 분리
        # 역할: /script.php/path/info 형식의 URL을 script.php와 /path/info로 분리
        # 동작: $fastcgi_script_name = /script.php, $fastcgi_path_info = /path/info
        fastcgi_split_path_info ^(.+?\.php)(/.*)$;

        # 파일 존재 검증
        # 역할: 실제 PHP 파일 존재 확인, 없으면 404 반환
        # 보안: PHP-FPM에 존재하지 않는 파일 요청 방지 (임의 코드 실행 차단)
        # 중요: cgi.fix_pathinfo=0 설정과 함께 사용하여 보안 강화
        if (!-f $document_root$fastcgi_script_name) {
            return 404;
        }

        # FastCGI 버퍼링 설정
        # 역할: PHP-FPM 응답 버퍼링으로 성능 최적화
        # 성능: 느린 클라이언트로부터 PHP-FPM 프로세스 보호
        fastcgi_buffering on;

        # 첫 번째 응답 버퍼 (헤더용)
        # 역할: HTTP 응답 헤더 저장
        # 계산: 16KB는 PHP 헤더 평균 크기 (4-8KB) + 여유분
        fastcgi_buffer_size 16k;

        # 추가 응답 버퍼 (본문용)
        # 역할: HTTP 응답 본문 저장
        # 계산: 64 × 16KB = 1MB 총 버퍼, PHP 응답 평균 크기 고려
        # 개선: PHP 애플리케이션은 JSON/HTML 응답이 크므로 버퍼 확대
        fastcgi_buffers 64 16k;

        # FastCGI 타임아웃 설정
        # 역할: PHP 스크립트 실행 타임아웃 제어
        # 계산: 60초(1분) 타임아웃
        # 참고: php.ini의 max_execution_time과 조율 필요
        fastcgi_connect_timeout 60s;
        fastcgi_send_timeout 60s;
        fastcgi_read_timeout 60s;

        # PHP-FPM 서버 주소
        # 역할: PHP-FPM 프로세스로 요청 전달
        # 요구사항: appname과 serviceport를 실제 값으로 변경 필요
        #   - Docker: appname:9000 (예: php-fpm:9000)
        #   - Unix 소켓: unix:/run/php/php8.2-fpm.sock (성능 더 좋음)
        #   - 로컬: 127.0.0.1:9000
        # 권장: Unix 소켓 사용 시 TCP 오버헤드 제거로 10-20% 성능 향상
        fastcgi_pass appname:serviceport;

        # 기본 인덱스 파일
        fastcgi_index index.php;

        # TCP 최적화 설정
        # tcp_nopush: 패킷 전송 최적화 제어
        # 역할: off로 설정하여 작은 응답도 즉시 전송 (PHP 동적 응답에 적합)
        # 참고: sendfile on일 때만 동작, 정적 파일에는 on 권장
        tcp_nopush off;

        # keepalive_requests: Keep-Alive 연결당 최대 요청 수
        # 역할: 0으로 설정하여 무제한 허용
        # 성능: 연결 재사용으로 TCP 핸드셰이크 오버헤드 감소
        # 개선: 0은 비표준 설정, 100-1000 값 권장으로 주석 추가
        # 권장: keepalive_requests 100; (연결당 100개 요청 후 재연결)
        keepalive_requests 0;
    }
} 