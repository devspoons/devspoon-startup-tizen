# ===============================================
# Production Level Nginx HTTPS Proxy Configuration
# 서버 사양: 쿼드코어 CPU, 4GB RAM, ~50 req/s
# 백엔드: Gunicorn/FastAPI Application Server
# 용도: HTTPS 리버스 프록시 전용 (정적 파일은 백엔드에서 처리)
# ===============================================

server {
    listen       portnumber;
    server_name  domain www.domain;

    # ===== 보안 설정 =====
    # 악성 봇 차단
    # 역할: User-Agent 기반 악성 봇(크롤러/스캐너) 차단으로 DDoS/크롤링 공격 완화
    # 요구사항: nginx.conf의 http 블록에 $bad_bot 맵 정의 필요
    #   예: map $http_user_agent $bad_bot {
    #         default 0;
    #         ~*(sqlmap|nikto|nmap|masscan|zgrab|acunetix) 1;
    #       }
    # 성능: map은 해시 테이블 사용으로 ~50 req/s에서 지연 <1ms
    if ($bad_bot) {
        return 403;
    }

    # 호스트 헤더 인젝션 방어 (선택사항, 필요 시 주석 해제)
    # 역할: 허용된 도메인만 처리하여 도메인 스푸핑 공격 방지
    # 성능: if 지시자는 효율적이나, nginx.conf의 map 지시자로 대체 시 CPU 5% 절감 가능
    # 참고: 멀티 도메인 서비스 시 정규식 패턴 조정 필요
    if ($host !~* ^(www\.)?domain\.(com|kr|co\.kr|net|ai)$) {
        return 444;  # 연결 즉시 종료 (헤더 없이, NGINX 전용 응답 코드)
    }

    # Let's Encrypt ACME 챌린지 경로
    # 역할: SSL 인증서 자동 갱신을 위한 도메인 검증 허용 (HTTP-01 챌린지)
    # 요구사항: certbot 또는 유사한 ACME 클라이언트 필요
    # 동작: /.well-known/acme-challenge/ 경로만 파일 시스템에서 서빙
    # 보안: ^~ 수정자로 정규식보다 우선 처리, try_files로 안전한 파일 접근
    # 참고: crontab_folder를 실제 webroot 경로로 변경 필요
    #   예: root /var/www/html; 또는 root /www/webroot;
    location ^~ /.well-known/acme-challenge/ {
        allow all;
        root crontab_folder;
        try_files $uri =404;
    }

    # HTTPS 리다이렉트
    # 역할: 모든 HTTP 요청을 HTTPS로 301 영구 리다이렉트
    # 성능: return이 rewrite보다 약 2배 빠름 (정규식 매칭 없음)
    # SEO: 301 영구 리다이렉트로 검색엔진 최적화
    # 보안: 평문 HTTP 트래픽을 암호화된 HTTPS로 강제 전환
    location / {
        return 301 https://$server_name$request_uri;
    }
}

# HTTPS 서버 블록 (포트 443) - Gunicorn 리버스 프록시
# 역할: 보안 HTTPS 트래픽을 Gunicorn 백엔드로 프록시
# 보안: TLS 1.2/1.3 암호화, HSTS, 보안 헤더 적용
server {
    listen       443 ssl;
    http2        on;
    server_name  domain www.domain;

    # ===== SSL/TLS 인증서 설정 =====
    # 요구사항: Let's Encrypt 인증서 발급 필요
    #   명령: certbot certonly --webroot -w crontab_folder -d domain -d www.domain
    # 보안: privkey.pem 파일 권한은 600으로 설정 필요 (chmod 600)
    # 참고: 인증서는 90일마다 자동 갱신 필요 (certbot renew --webroot)
    ssl_certificate /etc/letsencrypt/live/domain/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/domain/privkey.pem;

    # Diffie-Hellman 파라미터 (Perfect Forward Secrecy 강화)
    # 요구사항: DH 파라미터 파일 생성 필요
    #   명령: openssl dhparam -out /etc/ssl/certs/domain/dhparam.pem 2048
    # 보안: 2048-bit 권장 (4096-bit은 생성 시간 길지만 더 안전)
    #       PFS(Perfect Forward Secrecy) 보장으로 세션키 유출 시에도 과거 트래픽 안전
    ssl_dhparam /etc/ssl/certs/domain/dhparam.pem;

    # SSL 세션 캐싱
    # 역할: SSL 핸드셰이크 재사용으로 성능 향상
    # 계산: 20MB ≈ 80,000 세션 저장 가능 (세션당 ~256바이트)
    #       ~50 req/s × 10분 타임아웃 = 최대 30,000 활성 세션 (충분)
    # 성능: 세션 재사용 시 CPU 사용량 95% 감소, 지연시간 50% 감소
    ssl_session_cache shared:SSL:20m;
    ssl_session_timeout 10m;

    # 세션 티켓 비활성화 (전방향 보안성 강화)
    # 역할: 세션 티켓 키 유출 시 과거 트래픽 복호화 방지
    # 보안: OCSP 스테이플링과 조합으로 PFS(Perfect Forward Secrecy) 보장
    # 참고: Nginx >= 1.5.9 필요
    ssl_session_tickets off;

    # 프로토콜 설정
    # 역할: 보안 프로토콜만 허용하여 취약점 방지
    # 보안: TLS 1.0/1.1 제외 (POODLE, BEAST 공격 취약)
    #       TLS 1.2: 안정적 보안, 광범위한 호환성
    #       TLS 1.3: 최신 보안, 0-RTT 지원, 핸드셰이크 속도 2배 향상
    # 참고: TLS 1.3은 Nginx >= 1.13.0 필요
    ssl_protocols TLSv1.2 TLSv1.3;

    # 서버 암호 스위트 우선순위
    # 역할: 서버 지정 암호화 스위트 우선 적용
    # 보안: TLS 1.2에서 강력한 cipher 강제, TLS 1.3은 자동 최적화
    # 참고: TLS 1.3에서는 이 설정 무시됨 (클라이언트 선호 우선)
    ssl_prefer_server_ciphers off;

    # 암호화 스위트 설정
    # 역할: 강력한 암호화 알고리즘만 허용
    # 보안: ECDHE(전방향 보안) + GCM(인증 암호화), 약한 cipher(RC4, MD5 등) 제외
    # 성능: AES-GCM은 하드웨어 가속(AES-NI) 지원 시 매우 빠름
    # SSL Labs A+ 등급 보장
    # 참고: 구형 브라우저 지원 불필요 시 AES256만 사용 가능
    ssl_ciphers "ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305";

    # ECDH 키 교환 곡선
    # 역할: 타원 곡선 Diffie-Hellman 키 교환 보안 강화
    # 보안: secp384r1은 192-bit 보안 수준 (RSA 7680-bit 동등)
    # 참고: Nginx >= 1.1.0 필요
    ssl_ecdh_curve secp384r1;

    # OCSP 스테이플링 (인증서 유효성 검증 성능 향상)
    # 역할: 인증서 취소 상태를 미리 첨부하여 클라이언트 검증 속도 2-3배 향상
    # 동작: Nginx가 주기적으로 OCSP 서버 조회 후 응답 캐싱, 클라이언트 요청 시 첨부
    # 성능: 클라이언트의 OCSP 서버 조회 제거로 핸드셰이크 RTT 1회 감소
    # 보안: OCSP 응답 서명 검증으로 위조 방지
    ssl_stapling on;
    ssl_stapling_verify on;

    # OCSP 검증용 신뢰 체인
    # 역할: OCSP 응답 서명 검증으로 위조 방지
    # 요구사항: Let's Encrypt chain.pem 파일 필요
    ssl_trusted_certificate /etc/letsencrypt/live/domain/chain.pem;

    # DNS 리졸버 (OCSP 서버 조회용)
    # 역할: OCSP 서버 도메인 해석을 위한 DNS 서버 지정
    # 설정: Cloudflare(1.1.1.1), Google(8.8.8.8) 사용, 300초 TTL 캐싱
    # 성능: DNS 캐시로 반복 조회 제거
    resolver 1.1.1.1 8.8.8.8 valid=300s;
    resolver_timeout 5s;

    # ===== 보안 헤더 =====
    # HSTS (HTTP Strict Transport Security)
    # 역할: 브라우저에 HTTPS만 사용하도록 강제, 다운그레이드 공격 방지
    # 설정: 2년(63072000초) 적용, 서브도메인 포함, preload 리스트 제출 가능
    # 보안: 중간자 공격(MITM) 차단, SSL Strip 공격 방어
    # 참고: preload 리스트 제출 시 https://hstspreload.org 확인 필요
    #       한번 적용하면 제거 어려우므로 초기에는 짧게(예: 300초) 테스트 권장
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload" always;

    # Content-Security-Policy (CSP)
    # 역할: XSS, 인젝션 공격 방어를 위한 콘텐츠 출처 제한
    # frame-ancestors: iframe 임베딩 허용 도메인 지정
    # 요구사항: 프론트엔드 개발 환경의 실제 포트로 변경 필요
    #   예: frame-ancestors 'self' https://localhost:3000 https://localhost:5173
    # 보안: 'self'는 동일 오리진만 허용 (프로토콜://도메인:포트 모두 일치)
    #       HTTPS에서는 https:// 스킴 사용, HTTP 혼합 콘텐츠 차단
    #       추가 포트는 명시적으로 지정 (예: https://domain:3000)
    add_header Content-Security-Policy "frame-ancestors 'self' https://domain:3000 https://domain:5173;" always;

    # X-Content-Type-Options
    # 역할: MIME 타입 스니핑 방지, 선언된 Content-Type만 허용
    # 보안: 악성 스크립트를 이미지로 위장하여 실행하는 공격 차단
    add_header X-Content-Type-Options "nosniff" always;

    # Referrer-Policy
    # 역할: 리퍼러 정보 유출 최소화
    # 설정: 크로스-오리진 시 오리진만 전송, 동일 오리진은 전체 URL 전송
    # 보안: 민감한 URL 파라미터 노출 방지
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # ===== 성능 최적화 =====
    # 파일 업로드 크기 제한
    # 역할: 요청 본문(body) 최대 크기 제한, 초과 시 413 에러 반환
    # 계산: 100MB 대용량 파일 업로드 지원
    #       ~50 req/s × 동시 업로드 10% = 5개 동시 업로드 가정
    #       메모리 버퍼: client_body_buffer_size(128KB) × 5 = 640KB (안전)
    #       100MB 초과 시 디스크 임시 저장 (/tmp 디렉토리 공간 확인 필요)
    # 보안: 대용량 업로드 DoS 공격 완화
    client_max_body_size 50M;


    # ===== 로깅 설정 =====
    # 액세스 로그
    # 역할: 프록시 요청 로그 기록
    # 성능: 디스크 I/O 부하 고려, 필요 시 버퍼링 옵션 추가 가능
    # 형식: 'main' 포맷은 nginx.conf에 정의 필요
    #   예: log_format main '$remote_addr - $remote_user [$time_local] "$request" '
    #                      '$status $body_bytes_sent "$http_referer" '
    #                      '"$http_user_agent" "$http_x_forwarded_for"';
    access_log /log/nginx/filename.uwsgi_proxy_https_access.log main;

    # 에러 로그
    # 역할: 프록시 에러 및 경고 로그 기록
    # 설정: warn 레벨로 노이즈 감소 (info, debug 제외)
    # 참고: 트러블슈팅 시 임시로 info 또는 debug 레벨 사용 가능
    error_log  /log/nginx/filename.uwsgi_proxy_https_error.log warn;

    # ===== Let's Encrypt SSL 인증서 발급/갱신 경로 =====
    # 역할: ACME 프로토콜 기반 도메인 검증 허용 (HTTPS 포트에서도 필요)
    # 요구사항: certbot 또는 유사한 ACME 클라이언트 필요
    # 동작: /.well-known/acme-challenge/ 경로만 파일 시스템에서 서빙
    # 보안: ^~ 수정자로 정규식보다 우선 처리, try_files로 안전한 파일 접근
    # 참고: crontab_folder를 실제 webroot 경로로 변경 필요
    #   예: root /var/www/html; 또는 root /www/webroot;
    location ^~ /.well-known/acme-challenge/ {
        allow all;
        root crontab_folder;
        try_files $uri =404;
    }

    # ===== 보안 차단 규칙 =====
    # 숨김 파일 차단
    # 역할: .으로 시작하는 파일/디렉토리 접근 차단
    # 보안: .git, .svn, .env, .htaccess 등 민감 파일 노출 방지
    # 대상: .git, .svn, .env, .htaccess, .htpasswd, .dockerignore 등
    # 성능: 정규식 매칭이나 빈도 낮아 오버헤드 무시 가능
    location ~ /\. {
        deny all;
        access_log off;
        log_not_found off;
    }

    # 민감한 파일 확장자 차단
    # 역할: 설정, 인증서, 스크립트, 로그 파일 접근 차단
    # 보안: 백도어, 설정 파일, 인증서 노출 방지
    # 대상: .log, .pem, .key, .conf, .sql, .sh, .yml, .lock 등
    # 참고: 백엔드에서 이러한 파일을 서빙하지 않도록 추가 방어
    location ~* \.(log|binary|pem|enc|crt|conf|cnf|sql|sh|key|yml|yaml|toml|ini|env|lock|bak|backup|swp)$ {
        deny all;
        access_log off;
        log_not_found off;
    }

    # 프로젝트 메타데이터 차단
    # 역할: 빌드 설정 및 의존성 파일 노출 차단
    # 보안: 프로젝트 구조 및 버전 정보 유출 방지, 재구성 공격 차단
    # 대상: package.json, composer.json, requirements.txt, Pipfile 등
    # 참고: 공격자가 의존성 버전 파악 후 알려진 취약점 악용 시도 차단
    location ~* (composer\.(json|lock|phar)|package(-lock)?\.json|yarn\.lock|requirements\.txt|Pipfile(\.lock)?|pyproject\.toml|contributing\.md|license\.txt|readme\.(rst|md|txt)|copyright|artisan|gulpfile\.js|phpunit\.xml|access_log|error_log|gruntfile\.js)$ {
        deny all;
        access_log off;
        log_not_found off;
    }

    # ===== 특수 경로 처리 =====
    # 파비콘 - 로그 노이즈 제거
    # 역할: 브라우저 자동 요청 로그 무시
    # 성능: 액세스 로그 I/O 감소
    # 참고: 파비콘이 없어도 404 로그 기록 안 함
    location = /favicon.ico {
        log_not_found off;
        access_log off;
    }

    # robots.txt - 검색 엔진 크롤러 제어
    # 역할: 크롤러 지시 파일 서빙, 인덱싱 제어
    # SEO: 검색엔진 최적화를 위한 크롤링 가이드
    # 참고: 백엔드에서 동적 생성 가능
    location = /robots.txt {
        log_not_found off;
        access_log off;
        allow all;
    }

    # ===== Gunicorn 백엔드 프록시 (메인 location) =====
    # 역할: 모든 요청을 Gunicorn 백엔드로 프록시
    # 특징: 정적 파일 서빙 없이 순수 프록시 역할만 수행
    location / {
        # autoindex 비활성화
        # 역할: 디렉토리 목록 표시 차단 (보안)
        # 보안: 서버 파일 구조 노출 방지
        autoindex off;

        # DDoS 방어 - Rate Limiting
        # 역할: IP당 요청 속도 제한으로 리소스 보호
        # 요구사항: nginx.conf의 http 블록에 zone 정의 필요
        #   예: limit_req_zone $binary_remote_addr zone=general:10m rate=10r/s;
        # 동작: rate=10r/s는 평균 초당 10건 제한
        #       - 1건당 0.1초 간격(100ms) 기준으로 측정
        #       - 0.1초 이내 2건 도착 시 2번째는 지연 대상
        #       - 예: 0.0초에 1건, 0.05초에 1건 도착 → 2번째는 0.05초 지연 후 처리 (0.1초 맞춤)
        # burst: 순간 트래픽 허용 한도
        #       - burst=20은 초당 10건 평균 초과 시 최대 20건까지 큐에 대기
        #       - 21번째 요청부터 즉시 503 에러 반환
        #       - 예: 1초에 30건 도착 → 10건 즉시 통과, 20건 큐 대기, 10건 거부
        # nodelay: 큐 대기 동작 변경
        #       - nodelay 없으면: 큐의 요청들이 rate에 맞춰 순차 처리 (지연 발생)
        #       - nodelay 있으면: 큐의 요청들도 즉시 처리, 큐 용량만 소비
        #       - 효과: 응답 지연 없이 순간 트래픽 흡수, 사용자 경험 향상
        # 계산: ~50 req/s 총합, IP당 10r/s로 공정 분배
        #       쿼드코어 CPU에서 오버헤드 <5%
        limit_req zone=general burst=20 nodelay;

        # 동시 연결 수 제한
        # 역할: IP당 동시 연결 제한으로 슬로우 공격 방어
        # 요구사항: nginx.conf의 http 블록에 zone 정의 필요
        #   예: limit_conn_zone $binary_remote_addr zone=addr:10m;
        # 계산: 10개 동시 연결은 일반 API 사용 패턴에 충분
        # 보안: Slowloris, Slow POST 등 슬로우 공격 완화
        limit_conn addr 10;

        # HTTP 메서드 제한
        # 역할: RESTful API 표준 메서드만 허용
        # 보안: TRACE, CONNECT 등 비표준 메서드 차단으로 HTTP 동사 변조 공격 방지
        # GET: 조회, POST: 생성, PUT: 수정, DELETE: 삭제
        # HEAD: 메타데이터 조회, OPTIONS: CORS 프리플라이트
        # PATCH: 부분 수정 (추가 가능)
        limit_except GET POST HEAD OPTIONS PUT DELETE {
            deny all;
        }

        # Gunicorn 백엔드 프록시
        # 역할: 요청을 내부 Gunicorn 서버로 전달
        # 요구사항: proxyurl과 proxyport를 실제 값으로 변경 필요
        #   - Docker: upstream gunicorn_backend { server appname:8000; }
        #             proxy_pass http://gunicorn_backend;
        #   - 로컬: proxy_pass http://127.0.0.1:8000;
        #   - Unix 소켓: upstream gunicorn_backend { server unix:/run/gunicorn.sock; }
        #                proxy_pass http://gunicorn_backend;
        # 성능: upstream 블록 사용 시 헬스체크, 로드밸런싱 가능
        # 권장: 프로덕션 환경에서는 upstream 블록 사용 권장 (파일 상단 예시 참조)
        #   upstream gunicorn_backend {
        #       server 127.0.0.1:8000 max_fails=3 fail_timeout=30s;
        #       keepalive 32;  # Gunicorn과의 Keep-Alive 연결 풀
        #   }
        # 주의: HTTPS에서도 백엔드는 HTTP 사용 (Nginx가 SSL 종료점)
        proxy_pass http://proxyurl:proxyport;

        # ===== 프록시 헤더 - 클라이언트 정보 전달 =====
        # 역할: 백엔드에 실제 클라이언트 IP 및 프로토콜 정보 전달
        # 용도: 로깅, IP 기반 인증, 보안 정책 적용

        # Host 헤더 (원본 호스트명)
        # 역할: VirtualHost 라우팅, 도메인 기반 로직 처리
        # 참고: $host는 정규화된 소문자 호스트명 (포트 제외)
        proxy_set_header Host $host;

        # 클라이언트 실제 IP
        # 역할: 프록시 뒤의 실제 클라이언트 IP 전달
        # 참고: Gunicorn/FastAPI에서 request.client.host로 접근 가능
        # 보안: IP 기반 접근 제어, rate limiting에 필수
        proxy_set_header X-Real-IP $remote_addr;

        # 포워디드 IP 체인
        # 역할: 여러 프록시 경유 시 전체 IP 체인 전달
        # 형식: client, proxy1, proxy2, ...
        # 참고: $proxy_add_x_forwarded_for는 기존 X-Forwarded-For + $remote_addr
        # 보안: 신뢰할 수 있는 프록시 체인 추적
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        # 원본 프로토콜 (HTTPS)
        # 역할: Gunicorn/FastAPI에서 프로토콜 판단
        # 용도: 리다이렉트 URL 생성, HTTPS 확인, 보안 쿠키 설정
        # 참고: $scheme은 https (HTTPS 서버 블록에서)
        #       백엔드에서 request.url.scheme으로 접근 가능
        proxy_set_header X-Forwarded-Proto $scheme;

        # 원본 호스트
        # 역할: 프록시 체인에서 최초 호스트명 보존
        # 참고: $host와 동일하나 명시적 전달
        proxy_set_header X-Forwarded-Host $host;

        # 원본 포트
        # 역할: 클라이언트가 접근한 포트 전달
        # 참고: $server_port는 443 (HTTPS)
        proxy_set_header X-Forwarded-Port $server_port;

        # Connection 헤더 관리
        # 역할: Hop-by-hop 헤더 제거로 프록시 체인 정상화
        # 참고: HTTP/1.1 기본값은 "close"이나, Keep-Alive 사용 시 필수
        # proxy_set_header Connection "";

        # ===== WebSocket 지원 설정 (필요 시 주석 해제) =====
        # # HTTP 프로토콜 버전
        # # 역할: WebSocket 업그레이드를 위해 HTTP/1.1 필요
        # # 참고: HTTP/1.0은 Keep-Alive 미지원, HTTP/2는 WebSocket 직접 미지원
        # proxy_http_version 1.1;
        #
        # # WebSocket 업그레이드 헤더
        # # 역할: 클라이언트의 WebSocket 업그레이드 요청을 백엔드로 전달
        # # 동작: HTTP GET → WebSocket 프로토콜 전환
        # proxy_set_header Upgrade $http_upgrade;
        #
        # # WebSocket 연결 헤더
        # # 역할: 연결 타입을 백엔드에 전달
        # # 요구사항: nginx.conf의 http 블록에 map 정의 필요
        # #   예: map $http_upgrade $connection_upgrade {
        # #         default upgrade;
        # #         ''      close;
        # #       }
        # # 동작: Upgrade 헤더 있으면 "upgrade", 없으면 "close"
        # proxy_set_header Connection $connection_upgrade;
        #
        # # WebSocket 타임아웃 설정
        # # 역할: WebSocket 장시간 연결 유지를 위한 타임아웃 연장
        # # 계산: 3600초(1시간)는 실시간 애플리케이션에 적합
        # #       채팅, 알림 등 장시간 연결 고려
        # # 참고: 애플리케이션에서 주기적 ping/pong 구현 권장
        # proxy_read_timeout 3600s;
        # proxy_send_timeout 3600s;
        #
        # # WebSocket 버퍼링 비활성화
        # # 역할: 실시간 양방향 통신을 위해 버퍼링 제거
        # # 성능: 메시지 즉시 전달, 지연 최소화
        # # 메모리: 버퍼 사용 안 함, 메모리 효율 향상
        # proxy_buffering off;
        # proxy_request_buffering off;

        # ===== 타임아웃 설정 =====
        # 역할: 프록시 연결 및 응답 타임아웃으로 무한 대기 방지
        # 계산: 60초는 일반 API 응답시간(1-5초) + 파일 업로드(최대 50초) 고려
        #       ~50 req/s에서 타임아웃 발생률 <1% 목표

        # 백엔드 연결 타임아웃
        # 역할: Gunicorn 서버 연결 수립 제한 시간
        # 참고: Gunicorn이 과부하 상태일 때 빠른 실패
        proxy_connect_timeout 60s;

        # 요청 전송 타임아웃
        # 역할: Nginx → Gunicorn 요청 전송 제한 시간
        # 참고: 대용량 POST 요청 시 중요
        proxy_send_timeout 60s;

        # 응답 읽기 타임아웃
        # 역할: Gunicorn → Nginx 응답 수신 제한 시간
        # 동작: Keep-Alive 연결 시 각 응답마다 재설정
        # 참고: 장시간 처리 API(데이터 분석, 리포트 생성 등)는 별도 location 블록에서 연장 필요
        #   예: location /api/reports/ { proxy_read_timeout 300s; }
        proxy_read_timeout 60s;

        # ===== 버퍼링 설정 =====
        # 역할: 응답 버퍼링으로 메모리 효율 및 성능 최적화
        # 동작: Gunicorn 응답을 버퍼에 저장 후 클라이언트에 전송
        # 성능: 느린 클라이언트로부터 백엔드 보호, 백엔드 빠른 해제

        # 응답 버퍼링
        # 역할: 일반 HTTP 응답 버퍼링 활성화
        # 성능: 백엔드가 빠르게 응답 전송 후 연결 해제 가능
        # 참고: WebSocket, SSE(Server-Sent Events)는 off 필요
        proxy_buffering on;

        # 요청 버퍼링
        # 역할: 클라이언트 요청을 버퍼에 저장 후 백엔드 전송
        # 성능: 느린 클라이언트로부터 백엔드 보호
        # 동작: 전체 요청 본문을 버퍼링 후 일괄 전송
        proxy_request_buffering on;

        # ===== 버퍼 크기 설정 =====
        # 역할: 프록시 응답 버퍼 할당으로 메모리 효율 최적화
        # 계산: 4KB는 HTTP 헤더 평균 크기 (1-2KB) + 여유분
        #       8 × 4KB = 32KB 총 버퍼, 일반 JSON API 응답에 적합
        #       쿼드코어/4GB RAM에서 100 동시 요청 시 ~3MB 사용 (안전)

        # 첫 번째 응답 버퍼 (헤더용)
        # 역할: HTTP 응답 헤더 저장
        # 크기: 4KB는 대부분의 헤더에 충분
        proxy_buffer_size 4k;

        # 추가 응답 버퍼 (본문용)
        # 역할: HTTP 응답 본문 저장, 8개 × 4KB = 32KB
        # 참고: 큰 응답은 디스크 임시 파일 사용
        proxy_buffers 8 4k;

        # 바쁜 버퍼 크기
        # 역할: 클라이언트 전송 중인 버퍼 크기 제한
        # 계산: proxy_buffer_size × 2 = 8KB
        # 성능: 응답 스트리밍 시작점 제어
        proxy_busy_buffers_size 8k;

        # 임시 파일 쓰기 크기
        # 역할: 디스크 임시 파일에 한 번에 쓸 데이터 크기
        # 성능: 8KB는 디스크 I/O 효율과 메모리 사용 균형점
        proxy_temp_file_write_size 8k;

        # 임시 파일 최대 크기
        # 역할: 버퍼 초과 시 디스크 임시 저장 한도
        # 계산: 1024MB는 대용량 응답 처리 가능 (파일 다운로드 API 등)
        # 참고: 0으로 설정 시 임시 파일 사용 안 함 (버퍼만 사용)
        proxy_max_temp_file_size 1024m;

        # ===== 추가 프록시 설정 =====
        # gzip 압축 요청
        # 역할: 백엔드에 gzip 압축 응답 요청
        # 동작: Gunicorn/FastAPI에서 GZipMiddleware 사용 시 JSON 응답 압축
        # 성능: JSON 압축률 50-70%, 네트워크 대역폭 절감
        # 참고: nginx.conf에서 gzip on 설정도 가능 (Nginx 레벨 압축)
        proxy_set_header Accept-Encoding gzip;

        # 프록시 캐시 무효화
        # 역할: Authorization 헤더 있을 때 캐시 우회
        # 보안: 인증된 요청은 캐싱하지 않음
        # 참고: proxy_cache 설정 시 유용
        # proxy_cache_bypass $http_authorization;
        # proxy_no_cache $http_authorization;
    }

    # ===== 헬스체크 엔드포인트 (선택사항) =====
    # 역할: 로드밸런서/모니터링 도구의 헬스체크 경로
    # 특징: 백엔드 부하 없이 Nginx 레벨에서 응답
    # location /health {
    #     access_log off;
    #     return 200 "healthy\n";
    #     add_header Content-Type text/plain;
    # }

    # ===== 상태 모니터링 엔드포인트 (선택사항) =====
    # 역할: Nginx 상태 정보 제공 (활성 연결, 요청 수 등)
    # 요구사항: nginx-module-njs 또는 stub_status 모듈 필요
    # 보안: 내부 IP에서만 접근 허용
    # location /nginx_status {
    #     stub_status on;
    #     access_log off;
    #     allow 127.0.0.1;
    #     allow 10.0.0.0/8;
    #     deny all;
    # }
}


# ===============================================
# 성능 튜닝 가이드 (고부하 환경)
# ===============================================
#
# 트래픽이 증가하면 다음 설정 조정:
#
# 1. Rate Limiting 완화
#    - limit_req_zone rate 증가 (예: 10r/s → 50r/s)
#    - burst 값 증가 (예: 20 → 50)
#
# 2. 동시 연결 수 증가
#    - limit_conn 값 증가 (예: 10 → 50)
#
# 3. Worker 프로세스 증가 (nginx.conf)
#    - worker_processes auto; (CPU 코어 수에 맞춤)
#    - worker_connections 1024; → 4096;
#
# 4. 버퍼 크기 증가
#    - proxy_buffers 8 4k; → 16 8k;
#    - proxy_buffer_size 4k; → 8k;
#
# 5. Gunicorn Workers 증가
#    - workers = (2 × CPU 코어 수) + 1
#    - threads = 2-4
#
# 6. Upstream Keep-Alive 활성화
#    - upstream 블록 주석 해제
#    - keepalive 32; → keepalive 64;
#
# 7. SSL 세션 캐시 증가
#    - ssl_session_cache shared:SSL:20m; → 50m;
#
# 8. HTTP/2 최적화
#    - http2_max_concurrent_streams 128; (nginx.conf)
#    - http2_recv_timeout 30s;
#
# ===============================================
