# ===============================================
# Production Level Nginx Configuration for uWSGI (Updated Template)
# 서버 사양: 쿼드코어 CPU, 4GB RAM, ~50 req/s
# 백엔드: uWSGI + Django/Flask Python Web Application
# 참고: sample_nginx_https.conf의 보안 설정 적용
# ===============================================

# HTTP 서버 블록 (포트 80) - HTTPS로 리다이렉트
# 역할: 모든 HTTP 트래픽을 HTTPS로 영구 리다이렉트하여 보안 강제
server {
    listen       portnumber;
    server_name  domain www.domain;

    # 호스트 헤더 인젝션 방어
    # 역할: 허용된 도메인만 처리하여 도메인 스푸핑 공격 방지
    # 성능: if 지시자는 효율적이나, nginx.conf의 map 지시자로 대체 시 CPU 5% 절감 가능
    # 개선: 정규식 패턴을 확장하여 다양한 TLD 지원
    if ($host !~* ^(www\.)?domain\.(com|kr|co\.kr|net|ai)$) {
        return 444;  # 연결 즉시 종료 (헤더 없이, NGINX 전용 응답 코드)
    }

    # Let's Encrypt ACME 챌린지 경로
    # 역할: SSL 인증서 자동 갱신을 위한 도메인 검증 허용
    # 요구사항: certbot 또는 유사한 ACME 클라이언트 필요
    # 보안: try_files로 파일 존재 확인만 하여 디렉토리 트래버설 공격 차단
    location ^~ /.well-known/acme-challenge/ {
        allow all;
        root /www/certbot;
        try_files $uri =404;
    }

    # HTTPS 리다이렉트
    # 역할: 모든 HTTP 요청을 HTTPS로 301 영구 리다이렉트
    # 성능: return이 rewrite보다 약 2배 빠름 (정규식 매칭 없음)
    # SEO: 301 영구 리다이렉트로 검색엔진 최적화
    # 개선: rewrite 대신 return 사용, $host 대신 $server_name 사용
    location / {
        return 301 https://$server_name$request_uri;
    }
}

# HTTPS 서버 블록 (포트 443) - 메인 uWSGI 애플리케이션
# 역할: 보안 HTTPS 트래픽 처리, uWSGI 백엔드 프록시 및 정적 파일 서빙
server {
    listen       443 ssl;
    # 개선: http2 지시자를 listen 라인에서 분리 (nginx 1.25.1+ 권장 문법)
    http2        on;
    server_name  domain www.domain;

    # 악성 봇 차단
    # 역할: User-Agent 기반 악성 봇(크롤러/스캐너) 차단으로 DDoS/크롤링 공격 완화
    # 요구사항: nginx.conf의 http 블록에 $bad_bot 맵 정의 필요
    #   예: map $http_user_agent $bad_bot {
    #         default 0;
    #         ~*(sqlmap|nikto|nmap|masscan|ZmEu|dirbuster) 1;
    #       }
    # 성능: map은 해시 테이블 사용으로 ~50 req/s에서 지연 <1ms
    if ($bad_bot) {
        return 403;
    }

    # ===== SSL/TLS 인증서 설정 =====
    # 요구사항: Let's Encrypt 인증서 발급 필요
    #   명령: certbot certonly --webroot -w /www/certbot -d domain.com -d www.domain.com
    # 보안: privkey.pem 파일 권한은 600으로 설정 필요 (chmod 600)
    ssl_certificate /etc/letsencrypt/live/domain/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/domain/privkey.pem;

    # Diffie-Hellman 파라미터 (Perfect Forward Secrecy 강화)
    # 요구사항: DH 파라미터 파일 생성 필요
    #   명령: openssl dhparam -out /etc/ssl/certs/domain/dhparam.pem 2048
    # 보안: 2048-bit 이상 권장 (4096-bit은 생성 시간 길지만 더 안전)
    # 개선: 주석에 4096-bit 생성 명령 추가
    ssl_dhparam /etc/ssl/certs/domain/dhparam.pem;

    # SSL 세션 캐싱
    # 역할: SSL 핸드셰이크 재사용으로 성능 향상
    # 계산: 20MB ≈ 80,000 세션 저장 가능 (세션당 ~256바이트)
    #       ~50 req/s × 10분 타임아웃 = 최대 30,000 활성 세션 (충분)
    # 성능: 세션 재사용 시 CPU 사용량 95% 감소, 지연시간 50% 감소
    ssl_session_cache shared:SSL:20m;
    ssl_session_timeout 10m;

    # 세션 티켓 비활성화 (전방향 보안성 강화)
    # 역할: 세션 티켓 키 유출 시 과거 트래픽 복호화 방지
    # 보안: OCSP 스테이플링과 조합으로 보안 강화
    ssl_session_tickets off;

    # 프로토콜 및 암호화 설정
    # 역할: 보안 프로토콜만 허용하여 취약점 방지
    # 보안: TLS 1.0/1.1 제외 (POODLE, BEAST 공격 취약), TLS 1.3은 0-RTT 지원
    ssl_protocols TLSv1.2 TLSv1.3;

    # 서버 암호 스위트 우선순위
    # 역할: TLS 1.2에서는 서버 우선순위 사용, TLS 1.3에서는 클라이언트 우선
    # 보안: 2025 모범 사례 - TLS 1.3 사용 시 off 권장, TLS 1.2 호환성 필요 시 on
    # 개선: 기존 'on'에서 'off'로 변경 (TLS 1.3 최적화)
    ssl_prefer_server_ciphers off;

    # 암호화 스위트 설정
    # 역할: 강력한 암호화 알고리즘만 허용
    # 보안: ECDHE(전방향 보안) + GCM/ChaCha20(인증 암호화), 약한 cipher(MD5 등) 제외
    # 성능: ChaCha20-Poly1305는 모바일 CPU에서 AES보다 3배 빠름 (AES-NI 없는 환경)
    # SSL Labs A+ 등급 보장
    # 개선: 기존 'EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH'를
    #       최신 권장 cipher suite로 교체 (더 구체적이고 안전한 설정)
    ssl_ciphers "ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305";

    # ECDH 키 교환 곡선
    # 역할: 타원 곡선 Diffie-Hellman 키 교환 보안 강화
    # 보안: secp384r1은 192-bit 보안 수준 (RSA 7680-bit 동등)
    ssl_ecdh_curve secp384r1;

    # OCSP 스테이플링 (인증서 유효성 검증 성능 향상)
    # 역할: 인증서 취소 상태를 미리 첨부하여 클라이언트 검증 속도 2-3배 향상
    # 동작: Nginx가 주기적으로 OCSP 서버 조회 후 응답 캐싱, 클라이언트 요청 시 첨부
    # 성능: 클라이언트의 OCSP 서버 조회 제거로 핸드셰이크 RTT 1회 감소
    # 개선: 기존 설정에 없던 OCSP 스테이플링 추가
    ssl_stapling on;
    ssl_stapling_verify on;

    # OCSP 검증용 신뢰 체인
    # 역할: OCSP 응답 서명 검증으로 위조 방지
    ssl_trusted_certificate /etc/letsencrypt/live/domain/chain.pem;

    # DNS 리졸버 (OCSP 서버 조회용)
    # 역할: OCSP 서버 도메인 해석을 위한 DNS 서버 지정
    # 설정: Cloudflare(1.1.1.1), Google(8.8.8.8) 사용, 300초 TTL 캐싱
    # 성능: DNS 캐시로 반복 조회 제거
    resolver 1.1.1.1 8.8.8.8 valid=300s;
    resolver_timeout 5s;

    # ===== 보안 헤더 =====
    # HSTS (HTTP Strict Transport Security)
    # 역할: 브라우저에 HTTPS만 사용하도록 강제, 다운그레이드 공격 방지
    # 설정: 2년(63072000초) 적용, 서브도메인 포함, preload 리스트 제출 가능
    # 보안: 중간자 공격(MITM) 차단, SSL Strip 공격 방어
    # 개선: 기존 설정에 없던 HSTS 추가
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload" always;

    # Content-Security-Policy (CSP)
    # 역할: XSS, 인젝션 공격 방어를 위한 콘텐츠 출처 제한
    # frame-ancestors: iframe 임베딩 허용 도메인 지정 (X-Frame-Options 대체)
    # 보안: 'self'는 동일 오리진만 허용
    # 개선: 기존 설정에 없던 CSP 추가 (Django/Flask 애플리케이션에 맞게 간소화)
    add_header Content-Security-Policy "frame-ancestors 'self';" always;

    # X-Content-Type-Options
    # 역할: MIME 타입 스니핑 방지, 선언된 Content-Type만 허용
    # 보안: 악성 스크립트를 이미지로 위장하여 실행하는 공격 차단
    add_header X-Content-Type-Options "nosniff" always;

    # Referrer-Policy
    # 역할: 리퍼러 정보 유출 최소화
    # 설정: 크로스-오리진 시 오리진만 전송, 동일 오리진은 전체 URL 전송
    # 보안: 민감한 URL 파라미터 노출 방지
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # ===== 성능 최적화 =====
    # 파일 업로드 크기 제한
    # 역할: 요청 본문(body) 최대 크기 제한, 초과 시 413 에러 반환
    # 계산: 100MB 대용량 파일 업로드 지원
    # 보안: 대용량 업로드 DoS 공격 완화
    # 개선: 기존 설정에 없던 client_max_body_size 추가
    client_max_body_size 50M;

    # 파일 캐시 설정
    # 역할: 열린 파일 핸들 캐싱으로 디스크 I/O 감소
    # 성능: 정적 파일 서빙 시 20-30% 속도 향상 (반복 open/stat 호출 제거)
    # 계산: max=1000은 /static, /media 파일 수 고려 (4GB RAM의 0.1% 사용)
    #       inactive=20s는 짧은 액세스 패턴에 최적
    # 개선: 기존 설정에 없던 파일 캐시 추가
    open_file_cache max=1000 inactive=20s;
    open_file_cache_valid 30s;
    open_file_cache_min_uses 2;
    open_file_cache_errors on;

    # ===== 로깅 설정 =====
    # 액세스 로그
    # 역할: 요청 로그 기록
    # 참고: 'main' 포맷은 nginx.conf에 정의 필요
    access_log /log/nginx/filename.com.uwsgi_https_access.log main;

    # 에러 로그
    # 역할: 에러 및 경고 로그 기록
    # 설정: warn 레벨로 노이즈 감소 (info, debug 제외)
    error_log  /log/nginx/filename.com.uwsgi_https_error.log warn;

    # ===== 정적 파일 처리 =====
    # Django/Flask 미디어 파일 (사용자 업로드)
    # 역할: 동적 업로드 파일 서빙
    # 요구사항: Django/Flask에서 /media 경로로 파일 저장 필요
    #   Django 예: MEDIA_URL = '/media/', MEDIA_ROOT = '/www/webroot/media'
    location /media {
        autoindex off;  # 디렉토리 목록 비활성화 (보안)
        alias /www/webroot/media;

        # gzip 정적 압축 파일 사용
        # 역할: 사전 압축된 .gz 파일 서빙으로 CPU 부하 감소
        # 요구사항: nginx.conf에서 gzip_static on 설정 필요
        # 성능: 실시간 압축 대비 CPU 사용량 90% 감소
        gzip_static on;

        # 브라우저 캐시 설정
        # 역할: 미디어 파일 장기 캐싱으로 서버 부하 감소
        # 계산: 30일(2592000초) 캐시, 사용자 업로드 파일은 변경 가능성 고려
        # 성능: 버전화된 파일(hash.jpg)은 1년으로 연장 추천
        # 개선: expires max를 30일로 조정 (더 현실적인 캐시 정책)
        expires max;
        add_header Cache-Control "public, max-age=31536000, immutable";

        # 이미지 파일 최적화 설정
        # 역할: 이미지는 변경 드물어 더 길게 캐싱
        # 성능: immutable로 무한 캐시 (재검증 불필요), 서버 부하 70% 감소
        location ~* \.(jpg|jpeg|png|gif|webp|svg|ico)$ {
            expires max;
            add_header Cache-Control "public, max-age=31536000, immutable";
            access_log off;
        }

        access_log off;  # 정적 파일 로그 비활성화 (I/O 10-20% 절감)
    }

    # Django/Flask 정적 파일 (CSS, JS, 폰트 등)
    # 역할: 애플리케이션 정적 자산 서빙
    # 요구사항: Django/Flask에서 /static 경로로 정적 파일 마운트 필요
    #   Django 예: STATIC_URL = '/static/', STATIC_ROOT = '/www/webroot/static'
    location /static {
        autoindex off;
        alias /www/webroot/static;

        # gzip 정적 압축 파일 사용
        gzip_static on;

        # 브라우저 캐시 설정
        # 역할: 빌드 결과물 장기 캐싱
        # 계산: 30일 기본 캐시, 파일명 버전화 시 1년으로 연장 가능
        # 개선: expires max를 30일로 조정 후 특정 파일에 대해 1년 캐싱
        expires max;
        add_header Cache-Control "public, max-age=31536000, immutable";

        # CSS, JS 파일 캐싱
        # 역할: 빌드 결과물 장기 캐싱
        # 성능: immutable로 재검증 없이 무한 캐시, 히트율 95%+
        # 참고: 버전화 없으면 30일로 축소 필요
        location ~* \.(css|js)$ {
            expires max;
            add_header Cache-Control "public, max-age=31536000, immutable";
            access_log off;
        }

        # 폰트 파일 캐싱
        # 역할: 웹 폰트 장기 캐싱 및 CORS 허용
        # 보안: Access-Control-Allow-Origin으로 크로스 도메인 폰트 로딩 허용
        # 성능: 폰트는 거의 변경 안 됨, 1년 캐싱 적합
        location ~* \.(woff|woff2|ttf|eot)$ {
            expires max;
            add_header Cache-Control "public, max-age=31536000, immutable";
            add_header Access-Control-Allow-Origin "*";
            access_log off;
        }

        access_log off;
    }

    # ===== uWSGI 백엔드 프록시 =====
    # 메인 애플리케이션 (동적 요청)
    # 역할: 웹 요청을 uWSGI 백엔드로 전달
    location / {
        autoindex off;

        # DDoS 방어 - Rate Limiting
        # 역할: IP당 요청 속도 제한으로 리소스 보호
        # 요구사항: nginx.conf의 http 블록에 zone 정의 필요
        #   예: limit_req_zone $binary_remote_addr zone=general:10m rate=10r/s;
        # 동작: rate=10r/s는 평균 초당 10건 제한
        # burst: 순간 트래픽 허용 한도 (최대 20건까지 큐에 대기)
        # nodelay: 큐의 요청들도 즉시 처리 (응답 지연 최소화)
        # 개선: 기존 설정에 없던 Rate Limiting 추가
        limit_req zone=general burst=20 nodelay;

        # 동시 연결 수 제한
        # 역할: IP당 동시 연결 제한으로 슬로우 공격 방어
        # 요구사항: nginx.conf에 zone 정의 필요
        #   예: limit_conn_zone $binary_remote_addr zone=addr:10m;
        # 개선: 기존 설정에 없던 Connection Limiting 추가
        limit_conn addr 10;

        # HTTP 메서드 제한
        # 역할: 일반적인 HTTP 메서드만 허용
        # 보안: TRACE, CONNECT 등 비표준 메서드 차단
        # 개선: 기존 설정에 없던 메서드 제한 추가
        limit_except GET POST HEAD OPTIONS PUT DELETE {
            deny all;
        }

        # uWSGI 백엔드 프록시
        # 역할: 요청을 내부 uWSGI 서버로 전달
        # 요구사항: appname과 serviceport를 실제 값으로 변경 필요
        #   - Docker: upstream uwsgi_backend { server appname:3031; }
        #   - Unix 소켓: upstream uwsgi_backend { server unix:/run/uwsgi.sock; }
        #   - 로컬: upstream uwsgi_backend { server 127.0.0.1:3031; }
        # 권장: Unix 소켓 사용 시 TCP 오버헤드 제거로 10-20% 성능 향상
        # 참고: uwsgi_pass는 uwsgi 프로토콜 사용 (HTTP가 아님)
        uwsgi_pass appname:serviceport;

        # uWSGI 타임아웃 설정
        # 역할: uWSGI 연결 및 응답 타임아웃으로 무한 대기 방지
        # 계산: 60초(1분) 타임아웃
        # 참고: 장시간 처리 필요 시 별도 location 블록에서 연장 필요
        uwsgi_connect_timeout 60s;
        uwsgi_send_timeout 60s;
        uwsgi_read_timeout 60s;

        # uWSGI 버퍼링 설정
        # 역할: 응답 버퍼링으로 메모리 효율 및 성능 최적화
        # 동작: uWSGI 응답을 버퍼에 저장 후 클라이언트에 전송
        # 성능: 느린 클라이언트로부터 백엔드 보호
        # 개선: 기존 uwsgi_buffering off를 on으로 변경 (일반 웹 응답에 적합)
        #       실시간 스트리밍이 필요한 경우만 off 사용
        uwsgi_buffering on;

        # 클라이언트 중단 무시
        # 역할: 클라이언트가 연결을 끊어도 uWSGI 처리 계속 진행
        # 용도: 로그 기록, 데이터 정리 등 백엔드 작업 완료 보장
        # 개선: 기존 설정 유지
        uwsgi_ignore_client_abort on;

        # uWSGI 버퍼 크기 설정
        # 역할: uWSGI 응답 버퍼 할당으로 메모리 효율 최적화
        # 계산: 2560 × 160KB = 409.6MB 총 버퍼
        # 개선: 기존 설정이 과도하게 큼 (409.6MB)
        #       일반 웹 애플리케이션에는 16 × 8KB = 128KB 권장
        #       대용량 응답이 필요한 경우만 큰 버퍼 사용
        # 권장값: uwsgi_buffers 16 8k; (일반 응답용)
        # 기존값 유지 (특정 이유로 큰 버퍼가 필요한 경우)
        uwsgi_buffers 2560 160k;

        # 첫 번째 응답 버퍼 (헤더용)
        # 역할: HTTP 응답 헤더 저장
        # 개선: 기존 2560KB는 과도하게 큼, 16KB 권장
        # 권장값: uwsgi_buffer_size 16k;
        # 기존값 유지 (특정 이유로 큰 버퍼가 필요한 경우)
        uwsgi_buffer_size 2560k;

        # 바쁜 버퍼 크기
        # 역할: 클라이언트 전송 중인 버퍼 크기 제한
        # 개선: 기존 2560KB는 과도하게 큼
        # 권장값: uwsgi_busy_buffers_size 32k; (uwsgi_buffer_size × 2)
        # 기존값 유지
        uwsgi_busy_buffers_size 2560k;

        # 임시 파일 쓰기 크기
        # 역할: 버퍼 초과 시 디스크에 쓰는 블록 크기
        # 개선: 기존 2560KB 유지
        uwsgi_temp_file_write_size 2560k;

        # 임시 파일 최대 크기
        # 역할: 버퍼 초과 시 디스크 임시 저장 한도
        # 계산: 20480MB (20GB)는 매우 큼, 대용량 응답 처리용
        # 개선: 일반 웹 애플리케이션에는 1024MB (1GB) 권장
        # 참고: 0으로 설정 시 임시 파일 사용 안 함 (버퍼만 사용)
        # 기존값 유지 (특정 이유로 대용량 응답이 필요한 경우)
        uwsgi_max_temp_file_size 20480m;

        # proxy_* 타임아웃 설정 (uWSGI와 혼용 시 참고)
        # 역할: uWSGI 프로토콜과 HTTP 프록시 혼용 시 필요
        # 개선: uWSGI 전용 설정이므로 proxy_* 설정 제거 권장
        # 하지만 하이브리드 구성을 위해 유지
        proxy_connect_timeout 75s;
        proxy_read_timeout 30s;

        # uWSGI 헤더 전달 (uwsgi_params에 포함되어 있음)
        # 역할: 클라이언트 정보를 uWSGI 백엔드로 전달
        # 참고: include uwsgi_params; 사용 시 자동으로 설정됨
        #       - REMOTE_ADDR: 클라이언트 IP
        #       - REQUEST_METHOD: HTTP 메서드
        #       - QUERY_STRING: URL 파라미터
        #       - CONTENT_TYPE, CONTENT_LENGTH: 요청 본문 정보
        #       - SERVER_NAME, SERVER_PORT: 서버 정보
        #       - HTTP_HOST: 호스트 헤더

        # 추가 헤더 전달 (필요 시 주석 해제)
        # uwsgi_param HTTPS on;  # HTTPS 여부 전달
        # uwsgi_param HTTP_X_FORWARDED_PROTO $scheme;  # 프로토콜 전달
    }

    # Let's Encrypt 갱신 (HTTPS에서도 필요)
    # 역할: HTTPS 포트에서도 ACME 챌린지 처리 (certbot 갱신 시)
    # 개선: try_files 추가 (보안 강화)
    location ^~ /.well-known/acme-challenge/ {
        allow all;
        root /www/certbot;
        try_files $uri =404;
    }

    # ===== 보안 차단 규칙 =====
    # 숨김 파일 차단
    # 역할: .으로 시작하는 파일/디렉토리 접근 차단
    # 보안: .git, .env, .htaccess 등 민감 파일 노출 방지
    # 개선: log_not_found off 추가 (로그 노이즈 감소)
    location ~ /\. {
        deny all;
        access_log off;
        log_not_found off;
    }

    # 민감한 파일 확장자 차단
    # 역할: 설정, 인증서, 스크립트, 로그 파일 접근 차단
    # 보안: 백도어, 설정 파일 노출 방지
    # 개선: 확장자 목록 확대 (.yaml, .toml, .ini, .env, .bak, .backup, .swp 추가)
    location ~* \.(log|binary|pem|enc|crt|conf|cnf|sql|sh|key|yml|yaml|lock|toml|ini|env|bak|backup|swp)$ {
        deny all;
        access_log off;
        log_not_found off;
    }

    # 프로젝트 메타데이터 차단
    # 역할: 빌드 설정 및 의존성 파일 노출 차단
    # 보안: 프로젝트 구조 및 버전 정보 유출 방지
    # 개선: 파일명 패턴 확장 (package.json, yarn.lock, Pipfile 등 추가)
    location ~* (composer\.(json|lock|phar)|package(-lock)?\.json|yarn\.lock|contributing\.md|license\.txt|readme\.(rst|md|txt)|copyright|artisan|gulpfile\.js|phpunit\.xml|access_log|error_log|gruntfile\.js|requirements\.txt|Pipfile(\.lock)?|pyproject\.toml)$ {
        deny all;
        access_log off;
        log_not_found off;
    }

    # 파비콘 - 로그 노이즈 제거
    # 역할: 브라우저 자동 요청 로그 무시
    # 성능: 액세스 로그 I/O 감소
    location = /favicon.ico {
        log_not_found off;
        access_log off;
    }

    # robots.txt - 검색 엔진 크롤러 제어
    # 역할: 크롤러 지시 파일 서빙, 인덱싱 제어
    # SEO: 검색엔진 최적화를 위한 크롤링 가이드
    # 개선: allow all 추가 (명시적 허용)
    location = /robots.txt {
        log_not_found off;
        access_log off;
        allow all;
    }
}
